[[security]]
= Security

[#104]
== {MUST} Secure Endpoints with OAuth 2.0

Every API endpoint needs to be secured using OAuth 2.0. Please refer to
the
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#security-definitions-object[official
OpenAPI spec] on how to specify security definitions in you API
specification or take a look at the following example.

[source,yaml]
----
securityDefinitions:
  oauth2:
    type: oauth2
    flow: application
    tokenUrl: https://identity.zalando.com/oauth2/token
    scopes:
      fulfillment-order-service.read: Access right needed to read from the fulfillment order service.
      fulfillment-order-service.write: Access right needed to write to the fulfillment order service.      
----

The example defines OAuth2 with client credentials flow as security standard
used for authentication when accessing endpoints. Additionally, there are two
API access rights (permissions) defined via the scopes section for later
endpoint authorization usage (see <<105, next section>>).

It makes little sense specifying the flow to retrieve OAuth tokens in the
`securityDefinitions` section, as API endpoints should not care, how OAuth
tokens were created. Unfortunately the `flow` field is mandatory and cannot
be omitted. API endpoints should always set `flow: application` and ignore
this information.

[#105]
== {MUST} Define and Assign Permissions

APIs are must define permissions to protect their resources. Therefore, at
least one permission must be assigned to each endpoint. Permissions are
defined as shown in the <<104, previous section>>. The pattern for designing
permission <<225>> 


The naming schema for permissions correspond to the naming schema for <<224,
hostnames>> and <<213, event names>>. Please refer to <<225>> for designing
permission names.

APIs should stick to component specific permissions without resource extension
to avoid governance complexity of too many fine grained permissions. For the
majority of use cases, restricting access to specific API endpoints using read
and write is sufficient for controlling access for client types like merchant
or retailer business partners, customers or operational staff. However, in
some situations, where the API serves different types of resources for
different owners, resource specific scopes may make sense.

Some examples for standard and resource-specific permissions:

[cols="25%,20%,15%,40%",options="header",]
|=======================================================================
|Application ID |Resource ID |Access Type |Example
|`order-management` |`sales_order` |`read` |`order-management.sales_order.read`
|`order-management` |`shipment_order` |`read`|`order-management.shipment_order.read`
|`fulfillment-order` | |`write` |`fulfillment-order.write`
|`business-partner-service` | |`read` |`business-partner-service.read`
|=======================================================================

<!--
[cols="15%,15%,15%,15%,40%",options="header",]
|=======================================================================
| Domain | Component | Resource | Access Type | Example
| finance | exchange-rate | - | write | z::finance.exchange-rate.write 
| transactions | order | - | read | z::transactions.order.read
| customer | address | shipment-address | read  | z::customer.address.shipment-address.read
|=======================================================================
[cols="30%,15%,15%,40%",options="header",]
|=======================================================================
| Application | Resource | Access Type | Example
| business-partner-service | | - | read | z::business-partner-service.read
| order-management | sales_order | write | z::order-management.sales_order.write
|=======================================================================
-->

After permission names are defined and the permission is declared in the 
security definition at the top of an API specification, it should be assigned 
to each API operation by specifying a
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject[security
requirement] like this:

[source,yaml]
----
paths:
 /business-partners/{partner-id}:
    get:
      summary: Retrieves information about a business partner
      security:
        - oauth2:
          - business-partner.read
----

In very rare cases a whole API or some selected endpoints may not require
specific access control. However, to make this explicit you should assign the
`uid` pseudo permission in this case. It is the user id and always available
as OAuth2 default scope.

[source,yaml]
----
paths:
  /public-information:
    get:
      summary: Provides public information about ... 
               Accessible by any user; no permissions needed.
      security:
        - oauth2:
          - uid
----

Hint: you need not explicitly define the "Authorization" header; it is a
standard header so to say implicitly defined via the security section.


[#225]
== {MUST} Use organizational naming for permission names

As long as the <<223,functional naming>> is not supported for permissions,
permission names in APIs must conform to the organizational naming schema
as follows:

[source,bnf]
-----
<permission> ::= <standard-permission> |  -- should be sufficient for majority of use cases
                 <resource-permission> |  -- for special security access differentiation use cases
                 <pseudo-permission>      -- used to explicitly indicate that access is not restricted

<standard-permission> ::= <application>.<access-type>
<resource-permission> ::= <application>.<resource>.<access-type>
<pseudo-permission>   ::= uid

<resource>            ::= [a-z][a-z0-9-]*  -- free resource identifier
<application>         ::= [a-z][a-z0-9-]*  -- application identifier
<access-type>         ::= read | write    -- might be extended in future
-----

This pattern is compatible with the previous definition.

////
== {MUST} Use functional naming schema for permission names

Permission names in APIs are recommended to conform to the functional naming
schema (see <<223>> for details and registration of functional names) as
follows:

[source,bnf]
----
<permission> ::= <name-space>::<permission-name> |
                 <standard-permission> |  -- standard permission without functional naming
                 <resource-permission> |  -- resource specific permission without functional naming
                 <pseudo-permission>      -- used to explicitly indicate unrestricted access

<permission-name> ::= <functional-domain>[.<functional-component>].[<resource>].<access-type>

<name-space>           ::= z                -- fix prefix for all permissions

<functional-domain>    ::= [a-z][a-z0-9]*   -- domain managed by architecture team
<functional-component> ::= [a-z][a-z0-9-]*  -- functional name of owning component

<standard-permission>  ::= <application>.<access-type>
<resource-permission>  ::= <application>.<resource>.<access-type>
<pseudo-permission>    ::= uid

<resource>             ::= [a-z][a-z0-9-]*  -- free resource identifier
<application>          ::= [a-z][a-z0-9-]*  -- application identifier
<access-type>          ::= read || write    -- might be extended in future

----

**Note:** The `functional-domain` and `functional-component` must correspond
to the functional name of the owning application. The organizational
permission names are only allow for internal APIs (see <<223>>).
////